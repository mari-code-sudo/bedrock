name: 'SSL Certificate Renewal Pipeline Deploy Workflow'
on:
  push:
    branches: [ "main" ]

  workflow_dispatch:

      
jobs:
  renew_ssl_dev:
    name: 'Renew SSL Certificates'
    environment: dev
    runs-on: [ubuntu-latest]
    env:
      GH_TOKEN: "${{ secrets.PIPELINE_RENEWAL_GITHUB_TOKEN }}"


    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Certbot
        run: |
          sudo apt-get update
          sudo apt-get install -y certbot

      - name: Install Azure CLI
        run: |
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          az --version

      - name: Install GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh
      
      - name: Install openssl
        run: |
          sudo apt-get update
          sudo apt-get install -y openssl
        
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y certbot jq curl gh

      # - name: Check if Token is Expiring in 15 Days
      #   id: check_expiration
      #   run: |
      #     # Get the current date in YYYY-MM-DD format
      #     CURRENT_DATE=$(date +'%Y-%m-%d')

      #     # Get the stored expiration date from the secret
      #     EXPIRATION_DATE="${{ secrets.PIPELINE_RENEWAL_GITHUB_TOKEN_EXPIRATION_DATE }}"

      #     # Check if the expiration date is empty
      #     if [ -z "$EXPIRATION_DATE" ]; then
      #       echo "Error: Expiration date is empty or not set!"
      #       exit 1
      #     fi

      #     # Convert the human-readable expiration date to a format that 'date' can process (YYYY-MM-DD)
      #     EXPIRATION_DATE_FORMATTED=$(date -d "$EXPIRATION_DATE" +'%Y-%m-%d' 2>/dev/null)

      #     # If the conversion fails (invalid format), print an error and exit
      #     if [ $? -ne 0 ]; then
      #       echo "Error: Invalid expiration date format. The expected format is 'Wed, Apr 16 2025'."
      #       exit 1
      #     fi

      #     # Convert both dates to Unix timestamps for comparison
      #     CURRENT_DATE_TIMESTAMP=$(date -d $CURRENT_DATE +%s)
      #     EXPIRATION_DATE_TIMESTAMP=$(date -d $EXPIRATION_DATE_FORMATTED +%s)

      #     # Calculate the difference in days between current date and expiration date
      #     DIFF_DAYS=$(( ($EXPIRATION_DATE_TIMESTAMP - $CURRENT_DATE_TIMESTAMP) / 86400 ))

      #     # Check if the expiration date is within 15 days
      #     if [ $DIFF_DAYS -le 15 ]; then
      #       echo "Token is expiring within 15 days. Proceeding with renewal."
      #       echo "renew_token=true" >> $GITHUB_ENV
      #     else
      #       echo "Token is not expiring within 15 days. Skipping renewal."
      #       echo "renew_token=false" >> $GITHUB_ENV
      #     fi
        
      - name: Renew GitHub PAT if needed
        run: |
          echo "Renewing GitHub PAT..."
          
          # Make the API request to generate the new PAT and capture the response
          response=$(curl -X POST -H "Authorization: token $GH_TOKEN" \
            -d '{"scopes":["admin:org","repo","workflow"],"note":"Automated Token Renewal for SSL"}' \
            https://api.github.com/authorizations)

          # Check if the response contains a valid token
          NEW_PAT=$(echo "$response" | jq -r '.token')

          # If the token is null or empty, print an error and exit
          if [ "$NEW_PAT" == "null" ] || [ -z "$NEW_PAT" ]; then
            echo "Error: Failed to generate a new PAT. Response: $response"
            exit 1
          fi

          echo "New PAT generated: $NEW_PAT"

          # Save the new PAT to GitHub Secrets using the GitHub CLI
          gh auth login --with-token <<< "$NEW_PAT"
          gh secret set PIPELINE_RENEWAL_GITHUB_TOKEN --body "$NEW_PAT"
